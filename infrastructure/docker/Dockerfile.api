# =============================================================================
# API SERVICE DOCKERFILE - AQUACULTURE PLATFORM BACKEND CONTAINER
# =============================================================================
#
# WHAT IS THIS FILE?
# This Dockerfile is like a "recipe" for creating a Docker container that runs
# the main API service of the aquaculture platform. Think of it as instructions
# for packaging the backend application into a portable, self-contained unit.
#
# WHAT IS A DOCKER CONTAINER?
# A Docker container is like a "shipping container" for software:
# - Contains everything needed to run the application (code, dependencies, OS)
# - Runs the same way on any computer (laptop, server, cloud)
# - Isolated from other applications (can't interfere with each other)
# - Lightweight and fast to start/stop
#
# WHAT DOES THE API SERVICE DO?
# The API service is the "brain" of the platform that:
# - Handles user login and authentication
# - Manages fish farm data (ponds, sensors, feeding schedules)
# - Processes requests from the web and mobile apps
# - Connects to the database to store and retrieve information
# - Communicates with the ML service for predictions
#
# MULTI-STAGE BUILD EXPLAINED:
# This uses a "two-stage" build process like building a house:
# Stage 1 (Builder): Bring in construction tools and materials
# Stage 2 (Runtime): Keep only the finished house, remove construction tools
# Result: Smaller, faster, more secure final container
#
# KEY BENEFITS:
# - Smaller containers: Faster deployment and less storage space
# - Better security: No build tools in production (fewer vulnerabilities)
# - Faster startup: Less code to load means quicker application start
# - Cost savings: Smaller images use less bandwidth and storage
#
# AUTHOR: DevOps Team
# VERSION: 1.0.0
# UPDATED: 2024-10-26
# =============================================================================

# ============================================================================
# STAGE 1: BUILD STAGE
# ============================================================================
# Install Python dependencies with build tools and compilers

FROM python:3.10-slim as builder

# Set working directory for build operations
WORKDIR /app

# Install system build dependencies required for Python packages
# - gcc/g++: C/C++ compilers for native extensions
# - libpq-dev: PostgreSQL development headers for psycopg2
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*  # Clean package cache to reduce image size

# Copy Python requirements file
COPY requirements.txt .

# Install Python dependencies to user directory
# --no-cache-dir: Don't store pip cache (reduces image size)
# --user: Install to user directory for easy copying to final stage
RUN pip install --no-cache-dir --user -r requirements.txt

# ============================================================================
# STAGE 2: RUNTIME STAGE
# ============================================================================
# Create minimal runtime image with only necessary components

FROM python:3.10-slim

WORKDIR /app

# Install runtime system dependencies (no build tools needed)
# - libpq5: PostgreSQL client library (runtime only)
# - curl: For health checks and debugging
RUN apt-get update && apt-get install -y \
    libpq5 \
    curl \
    && rm -rf /var/lib/apt/lists/*  # Clean package cache

# Copy Python dependencies from builder stage
COPY --from=builder /root/.local /root/.local

# Add Python user packages to PATH
ENV PATH=/root/.local/bin:$PATH

# Copy application source code
COPY services/api /app/services/api
COPY services/__init__.py /app/services/__init__.py

# ============================================================================
# SECURITY: NON-ROOT USER SETUP
# ============================================================================
# Create and configure non-root user for enhanced security

# Create application user with specific UID for consistency
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app

# Copy Python dependencies to appuser's home directory
RUN cp -r /root/.local /home/appuser/.local && chown -R appuser:appuser /home/appuser/.local

# Switch to non-root user
USER appuser

# Update PATH for appuser to access installed packages
ENV PATH=/home/appuser/.local/bin:$PATH

# ============================================================================
# CONTAINER CONFIGURATION
# ============================================================================

# Expose the FastAPI application port
EXPOSE 8000

# ============================================================================
# HEALTH CHECK CONFIGURATION
# ============================================================================
# Configure container health monitoring for orchestration systems

HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Health check parameters explained:
# --interval=30s: Check every 30 seconds
# --timeout=10s: Timeout after 10 seconds
# --start-period=40s: Grace period for application startup
# --retries=3: Mark unhealthy after 3 consecutive failures

# ============================================================================
# APPLICATION STARTUP
# ============================================================================
# Start the FastAPI application with Uvicorn ASGI server

CMD ["python", "-m", "uvicorn", "services.api.main:app", "--host", "0.0.0.0", "--port", "8000"]

# Command parameters:
# --host=0.0.0.0: Bind to all network interfaces (required for containers)
# --port=8000: Listen on port 8000 (matches EXPOSE directive)
# services.api.main:app: Python module path to FastAPI application instance
